

#include "inmost.h"

using namespace INMOST;
std::string problem_name = "circular_permeability";

int main(int argc, char ** argv)
{
	if( argc < 3 )
	{
		std::cout << "Usage: " << argv[0] << " mesh mesh_out [Kx:10 Ky:100 Kz:100 radius:0.34 power:3]" << std::endl;
		return 0;
	}
	
	Mesh * m = new Mesh;
	m->SetFileOption("VERBOSITY","2");
	try{m->Load(argv[1]);} catch(...) { std::cout << "Cannot load the mesh " << argv[1] << std::endl; return -1;}


	double max[3] = {-1.0e20, -1.0e20, -1.0e20}, min[3] = {1.0e20,1.0e20,1.0e20};
	Storage::real c[3] = {0,0,0};
	for(Mesh::iteratorNode it = m->BeginNode(); it != m->EndNode(); ++it)
	{
		it->Centroid(c);
		if( c[0] > max[0] ) max[0] = c[0];
		if( c[1] > max[1] ) max[1] = c[1];
		if( c[2] > max[2] ) max[2] = c[2];
		if( c[0] < min[0] ) min[0] = c[0];
		if( c[1] < min[1] ) min[1] = c[1];
		if( c[2] < min[2] ) min[2] = c[2];
	}

	if( max[0] <= min[0] ) {std::cout << "strange X " << min[0] << ":" << max[0] << std::endl; return -1;}
	if( max[1] <= min[1] ) {std::cout << "strange Y " << min[1] << ":" << max[1] << std::endl; return -1;}
	if( max[2] <= min[2] ) min[2] = max[2] = 0.0; //2d mesh

	Tag material;
	if( m->HaveTag("MATERIAL") ) material = m->GetTag("MATERIAL");
	if( m->HaveTag("PERM") ) m->DeleteTag(m->GetTag("PERM"));

	Tag tensor = m->CreateTag("PERM",DATA_REAL,CELL,NONE,6);

  Storage::real Kx0 = 10.0, Ky0 = 100.0, Kz0 = 100.0;
  Storage::real radius = 0.34, power = 3;

  if( argc > 3 ) Kx0 = atof(argv[3]);
  if( argc > 4 ) Ky0 = atof(argv[4]);
  if( argc > 5 ) Kz0 = atof(argv[5]);
  if( argc > 6 ) radius = atof(argv[6]);
  if( argc > 7 ) power = atof(argv[7]);
    
    {
        Storage::bulk_array name = m->self()->BulkArray(m->CreateTag("PROBLEMNAME",DATA_BULK,MESH,NONE));
        name.replace(name.begin(),name.end(),problem_name.begin(),problem_name.end());
    }


  std::cout << "Setting circular permeability" << std::endl;

	for(Mesh::iteratorCell it = m->BeginCell(); it != m->EndCell(); ++it)
	{
		it->Centroid(c);
		Storage::real alpha = (c[0]-min[0])/(max[0]-min[0]) - 0.5;
		Storage::real beta  = (c[1]-min[1])/(max[1]-min[1]) - 0.5;
		Storage::real circ = radius - sqrt(alpha*alpha + beta*beta);
		Storage::real rad = pow(fabs(1.0 - fabs(circ)),power);
		Storage::real_array perm = it->RealArrayDF(tensor);
		std::fill(perm.begin(),perm.end(),0.0);
		Storage::real Kx = Kx0*rad;
		Storage::real Ky = Ky0*rad;
			

		//if( circ > -0.125 )
		{
			//circularly rotated tensor
			Storage::real angle = atan2(beta,alpha);
			Storage::real acos = cos(angle);
			Storage::real asin = sin(angle);
			perm[0] = Kx * acos * acos + Ky * asin * asin;
			perm[1] = (Kx - Ky) * acos * asin;
			perm[2] = 0.0;
			perm[3] = Ky * acos * acos + Kx * asin * asin;
			perm[4] = 0.0;
			perm[5] = Kz0;	
		}
		
		if( (alpha < -0.33 && beta < -0.33) || (alpha > 0.33 && beta > 0.33) )
		{
      //45 degree rotation
		  //guides initial flow as narrow stream into circle
			perm[0] = (Kx + Ky)*0.5;
			perm[1] = (Ky - Kx)*0.5;
			perm[2] = 0.0;
			perm[3] = perm[0];
			perm[4] = 0.0;
			perm[5] = Kz0;
		}
		
		
		if( material.isValid() )
		{
      //isotropic tensor
      //handle corners with wells for meshes generated by Bradley
			
			if( it->Integer(material) == 1 || it->Integer(material) == 2 || it->Integer(material) < 0 )
			{
				perm[0] = 100;
				perm[1] = 0;
				perm[2] = 0;
				perm[3] = 100;
				perm[4] = 0;
				perm[5] = 100;
			}
			else if( it->Integer(material) > 2 ) //set impermiable inclusions
				std::fill(perm.begin(),perm.end(),0.0);
		}
		
	}

  std::cout << "Saving output to " << argv[2] << std::endl;

	m->Save(argv[2]);

	delete m;
}

